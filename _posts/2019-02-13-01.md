---
layout: post
author: Kim
title: 前端工程师需要了解的浏览器
tags: ['面试']
---

前端工程师面试的时候常常会被问到浏览器工作原理，有很多小伙伴会有疑惑，这部分知识有用？我的回答是有用，但我们要掌握学习的深度，毕竟浏览器是门大学问，我们并不用学成“浏览器开发工程师”。所以这篇文章，我们把范围圈定在“前端工程师需要了解的”程度。

我以 Chrome 完成一次页面请求为例，大致过程是这样的：

1. 当用户输入 URL 并确认后，浏览器调用资源加载器加载该 URL 对应的网页
1. 加载器依赖网络模块建立连接，发送请求并接收答复
1. 将接收到的网页交给 HTML 解释器处理，构建 DOM 树
1. CSS 解释器将 CSS 文件解释成样式信息，并附加到 DOM 树上，构建绘图上下文
1. 生成最终图像

下面我们对每一步做些深入了解。

### Step 1

地址栏输入的 URL 通过 **UI 线程**进行解析，将解析后的字符串交给 **Network 线程**进行 DNS 解析，查找主机 IP，然后发起请求。

由于 DNS 解析是个很慢的过程，所以浏览器会将解析后的 DNS 缓存起来，避免每次都去解析，提高性能。

上面提到的 2 个线程，严格来说不是属于 Chrome 浏览器的，而是属于 Webkit 内核。Webkit 是个多线程内核，每个线程负责不同的部分，这样的好处是不会因为一个页面的崩溃，而引起其他页面崩溃的连锁反应。缺点是比较耗资源，不过现在大部分计算机都是资源过剩，这个缺点也就被无限缩小了。

### Step 2

这个步骤里面涉及了几个比较重要的知识点：建立连击、发送请求

**建立连接**就是我们一直提到的 **TCP 连接的三次握手**：

1. Client 向 Server 发送请求连接报文 SYN
1. Server 接到后向 Client 回复 SYN + ACK
1. Client 接到后向 Client 发送 ACK 报文

**发送请求**就是利用 HTTP 协议请求资源。这里顺便说下在 TCP/IP 四层模型中，TCP 属于传输层，HTTP 属于应用层。

那么如果是 **HTTPS 协议**呢？与 HTTP 唯一的区别就是，HTTPS 会在 TCP 连接建立后，再与服务器建立一条 TLS 加密通道（安全层），将传输内容通过通道进行传输。

在接收完答复后，会断开 TCP 连接（当然也可能不断开，但为了过程完整，这里就假设断开），需要进行 **四次挥手**：

1. Client 向 Server 发送 FIN 报文，说明要关闭连接
2. Server 向 Client 发送 ACK 报文，说明接到关闭连接的请求，正在做关闭前处理
3. Server 向 Client 发送 FIN 报文，说明开始关闭连接
4. Client 向 Server 发送 ACK 报文，确认等待关闭

### Step 3

HTML 解释器会将网页处理成一系列的词语（Token），最终生成 DOM 树，大体步骤如下：

1. 解释器从字节流中读取字符
1. 每读取一个字符，就放入状态机中进行词法分析
1. 词法分析会生成一个个**词语（Token）**
1. 多个 **Token** 按照一定的规则组成 **节点（Node）**
1. **Node** 间按照层级关系构建成 **DOM 树**

### Step 4

DOM 树附加上样式信息，就生成了 RenderObject 树，同时生成的还有 RenderLayer 树和**绘图上下文**。RenderObject 和 RenderLayer 我们知道下就好，重点关注绘图上下文。

在绘图上下文中会进行页面的**布局计算**（重排 reflow）、**位图绘制**（重绘 redraw）和图层合并等操作。

这里会涉及到一个 **GPU 加速**的概念，被加速的元素会独立出来，自身的变动不再影响 DOM 结构（也就是不会发生重排）。符合下面的条件之一的元素会被 GPU 加速：

- 有 `transform` 属性
- 有 `perspective` 属性
- `<video>`
- `<canvas>`
- 拥有动画属性

我们尽量让经常变动的元素处于 GPU 加速状态下。

### Step 5

将处理后的绘图上下文绘制出来。

---

最后再啰嗦一句，浏览器（或者说内核）的解析过程并不是**线性**的，而是**流式**的，所以步骤 3 和 4 是循环交替进行的。
